= Автоматический контроль качества документации в{nbsp}Asciidoc или{nbsp}DocOps для{nbsp}Хабра

ifdef::backend-fodt[]
image::sidi-i-pishi-pravilqno.png[]
endif::[]

ifndef::backend-fodt[]
image::https://habrastorage.org/webt/4r/0i/im/4r0iimulq-nblotfvgwoy5m0t1q.png[]
endif::[]

Один из шагов выпуска документации -- это применение алгоритмов автоматического контроля качества. Часть подходов будет применима только к документации ИТ-продуктов, часть -- к любым видам документации.

Для примеров использована https://github.com/fiddlededee/asciidoc-quality-gates[сама статья]. По указанной ссылке можно посмотреть данную статью в формате https://fiddlededee.github.io/asciidoc-quality-gates/[html], скачать https://fiddlededee.github.io/asciidoc-quality-gates/statqya.odt[odt] и https://fiddlededee.github.io/asciidoc-quality-gates/statqya.pdf[pdf] версию, а также открыть текст в формате, https://fiddlededee.github.io/asciidoc-quality-gates/statqya.md[который принимает Хабр].

Обратите внимание, в новой версии редактора Хабр некорректно происходит вставка списков. Лучше использовать старую версию.

== Точка применения алгоритмов контроля качества документации

Документация -- это совокупность данных и документов. Используя для создания документации такие инструменты, как Asciidoc, мы предполагаем, что данные для построения документов хранятся в одном или нескольких репозиториях, точно так же, как обычный программный код.

При любом изменении документации в репозитории обязательна проверка качества документов, которые выпускаются на основе данных репозитория. При ручной проверке документов этот процесс затратен и ограничен. А автоматические тесты можно проводить практически в любом объеме.

Если документация расположена в нескольких репозиториях, должен быть отдельный репозиторий с набором совместимых версий документации. При изменении этих версий необходимо проверить согласованность данных во всех репозиториях.

Если мы говорим о документировании ИТ-системы, программный код является элементом документации, на него распространяется указанное правило. Код и документацию следует на согласованность.

Указанные проверки обычно производят в момент добавления данных в репозитории при помощи систем контроля версий. Мы используем Github и Gitlab и встроенные в эти системы CI/CD-инструменты. В сложных случаях дополнительно используем Jenkins.

== Фреймворк тестирования

Для тестирования документации подходят любые фреймворки. В своих статьях я делаю примеры с использованием инструментов экосистемы Ruby, т.к. сам Asciidoctor написан на Ruby, поэтому в статье будет использована библиотека `minitest`.

== Проверка оформления исходных файлов в формате Asciidoc

Насколько мне известно, для проверки оформления исходных файлов в формате Asciidoc поддерживаемых проектов нет.

Мы используем простейшие проверки при помощи регулярных выражений.

Ключевое слово `describe` описывает содержание каждой проверки.

----
include::test.rb[tag=test_isx_fajla]
----

== Проверка содержания текста (грамматика, орфография и{nbsp}т.п.)

=== Исходные файлы или выходные документы?

Проверять содержание текста можно как в исходных файлах, так и в выходных. С моей точки зрения, в большинстве случаев проверять имеет смысл именно выходные документы, а не исходные файлы Asciidoc. Например, в Asciidoc активно используют атрибуты и может возникнуть ситуация, при которой ошибку будет пропущена:

----
:document: документ
{document}овация
----

:document: документ

В исходном документе ошибки нет, а вот выходное слово [.no-spell]`{document}овация` ошибку содержит.

=== Все ли понимают Asciidoc

Существует множество готовых инструментов, которыми можно проверять текстовые документы: например, [.no-spell]`vale`, [.no-spell]`textlint`, [.no-spell]`aspell`, [.no-spell]`Language Tool`.

Часть из этих инструментов поддерживают синтаксис Asciidoc. Но степень этой поддержки разная. Asciidoctor -- самый богатый язык среди языков текстовой разметки, реализация в перечисленных средствах поддержки синтаксиса Asciidoctor может быть неполной или вообще неверной с точки зрения ваших требований к тексту.

Обычно, подобные проблемы легко преодолеть. Например, для [.no-spell]`textlint` есть https://github.com/seikichi/textlint-plugin-asciidoctor[плагин], представление элементов в объектном дереве [.no-spell]`textlint` определено в https://github.com/seikichi/textlint-plugin-asciidoctor/blob/master/src/parse.js[этом файле]. Его можно легко поменять. Но иногда самой модели [.no-spell]`textlint` может не хватить для проведения всех необходимых видов тестирования.

Как я уже говорил проверять статическим анализатором лучше выходные документы. В Asciidoctor нет встроенной функции, которая превращает исходники в формате Asciidoc в составной Asciidoc-файл. Но Дэн Аллен сделал https://github.com/asciidoctor/asciidoctor-extensions-lab/blob/master/scripts/asciidoc-coalescer.rb[специальный скрипт], который справляется с данной задачей.

=== Использование шаблонов Asciidoctor

Альтернативный способ подключения к Asciidoctor любых статических анализаторов -- это превращение документа в текстовый файл. При этом появляется возможность размещать в данный файл дополнительную информацию, которая позволит понять, в каких исходниках произошла ошибка.

Для того, чтобы извлечь текст для проверки, Asciidoc поддерживает механизм шаблонов. Наименование папки с шаблонами передают в ключе `-t`.

Например, в следующем примере показан шаблон [.no-spell]`inline_quoted.slim`, который помещает в файл только куски текста, не содержащие роль [.no-spell]`no-spell`.

----
include::slim/spell/inline_quoted.slim[]
----

Далее в примере показано использование утилиты [.no-spell]`aspell` непосредственно для выполнения функции проверки.

----
include::_compile.sh[tag=spell_asciidoctor]
----

Само тестирование можно выполнить следующим образом:

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=ne_soderzhit_orf_oshibok]
...
include::test.rb[tag=test_fin_describe_end]
----

Тест, написанный таким образом, удобен тем, что в выводе [.no-spell]`minitest` будет информация об ошибочно написанных словах:

----
  1) Failure:
Final document #test_0001_has no typos  [test.rb:30]:
--- expected
+++ actual
@@ -1,3 +1 @@
-"Адин
-шогов
-"
+""
----

Аналогичный подход можно использовать для реализации всевозможных самостоятельных проверок -- отсутствие запрещенных слов, запрет параграфов, задаваемых несколькими строками и{nbsp}т.п.

Последняя проверка заслуживает отдельного внимания, т.к. её отсутствие -- частый источник ошибок. Рассмотрим следующий пример.

----
Я
иду
в магазни
----

Поскольку перенос строки заменяется на пробел, параграф правильно отобразится в конечном документе. Следующий пример, оформленный аналогичным образом, уже приведёт к ошибке.

----
Неправильно оформленный список:
* Первый пункт
* Второй пункт
----

Так как после первого предложения отсутствует пустая строка, на выходе получится:

----
Неправильно оформленный список: * Первый пункт * Второй пункт
----

Запретить такое оформление достаточно просто. В шаблоне [.no-spell]`paragraph.slim` необходимо указать, что в выходной файл выводится исходный текст параграфа ([.no-spell]`source`):

----
include::slim/break-line/paragraph.slim[]
----

В примере к исходному тексту параграфа добавлены два символа переноса строки, чтобы отличать этот (правильный) случай от случая с одним переносом.

И далее в тесте необходимо искать параграфы, в которых есть переносы строк:

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=bez_perenosov_strok]
...
include::test.rb[tag=test_fin_describe_end]
----

Обратите внимание, после знака `+` перенос разрешён, т.к. это специальный синтаксис Asciidoctor, который позволяет вставить в абзац мягкие переносы.

Следующий тест выявляет различные несуразности в тексте.

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=russian_pretty]
...
include::test.rb[tag=test_fin_describe_end]
----

== Встроенные проверки Asciidoctor

Asciidoctor содержит собственные механизмы проверки. Для этого его необходимо запустить в режиме [.no-spell]`Verbose`. Самые типовые выявляемые ошибки -- битые ссылки внутри документа, нарушенная иерархия заголовков, отсутствие включаемых файлов и{nbsp}т.п. Для этого в командной строке используется ключ `-v`, как в следующем примере.

----
include::_compile.sh[tag=docbook_asciidoctor]
----

Можно также запустить тестирование из библиотеки [.no-spell]`minitest`:

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=bez_oshibok_asciidoctor]
...
include::test.rb[tag=test_fin_describe_end]
----

== Проверка структуры документов при помощи Docbook

Поскольку Asciidoctor изначально создавался как средство написания документов в формате Docbook, но в простом текстовом формате, то поддержка экспорта в формат Docbook реализована очень качественно.

Docbook -- это вариант XML. Для тестирования структуры xml-файлов обычно используют два подхода.

=== Проверка при помощи схемы документа

XML поддерживает несколько стандартов схем документов. На сегодня самый распространенный -- xsd-схемы.

Учитывая то, что Asciidoc поддерживает очень много элементов синтаксиса и не каждый конвертер корректно работает со всеми элементами (а Хабр вообще мало, что поддерживает), в примере ограничим используемые элементы параграфами, маркированными списками и врезками кода, также разрешим картинку после заголовка:

----
include::statqya.xsd[]
----

В тесте проверка выглядит следующим образом:

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=bez_oshibok_struktura]
...
include::test.rb[tag=test_fin_describe_end]
----

Обычно такой подход применяют к кускам документа. В DITA -- есть термин [.no-spell]`topic` (тема). В зависимости от типа темы мы можем определять её структуру. Все темы определенного типа будут иметь одинаковую структуру.

Это удобно, если в документации активно используются похожие блоки.

=== Проверка при помощи xpath-выражений

Xpath-выражения --  инструмент, который позволяет делать выборки из файлов в формате xml.

Полученную выборку можно проанализировать на соответствие определенным правилам.

Например, в следующем примере мы проверяем, что в элементе списка не может быть более одного абзаца.

Эту задачу можно было бы решить, прописав в предыдущей схеме ограничение на один элемент типа [.no-spell]`simpara`, но часто формулировка локальных правил в виде xpath-выражений проще:

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=bez_oshibok_struktura_xpath]
...
include::test.rb[tag=test_fin_describe_end]
----

Этот же подход можно использовать для проверки сложных правил, не описываемых xsd-схемой, например, соответствие списка терминов тексту или работоспособность внешних ссылок:

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=bez_oshibok_ssyhlki]
...
include::test.rb[tag=test_fin_describe_end]
----

== Проверка соответствия документации коду

В статье https://habr.com/ru/post/562108/[Автоматическая генерация технической документации] рассмотрены инструменты автоматической генерации текстовых фрагментов из кода. Обычно формирование этих фрагментов происходит не в момент сборки документации, а при её подготовке.

Например, вы используете описание различных методов из спецификации [.no-spell]#OpenAPI#. Предположим, есть шаблон, превращающий эту спецификацию в необходимые фрагменты текста. Если спецификация была изменена, необходимо заново сгенерировать соответствующие фрагменты и проверить, что они корректно легли в существующие документы.

В момент сборки имеет смысл проверить, что сформированные фрагменты текста соответствуют текущей версии спецификации. Для этого достаточно запустить генерацию фрагментов и проверить, что полученные файлы полностью совпадают с версиями, которые находятся в проекте документации.

== Проверка выходных файлов

Документация представляется пользователю в удобочитаемых форматах, например, html, pdf, odt, docx и{nbsp}т.п.

Если вы используете стандартные конвертеры Asciidoctor, возможно, выходной файл проверять не надо. Но желательно открыть и сохранить файл в нативном приложении. Например, в https://github.com/CourseOrchestra/asciidoctor-open-document[моём проекте] сделана специальная точка вызова, которая конвертирует файл и автоматически открывает/сохраняет его при помощи LibreOffice Writer. Достаточно проверить, что выходной файл есть.

----
include::test.rb[tag=test_fin_describe]
...
include::test.rb[tag=estq_odt]
...
include::test.rb[tag=test_fin_describe_end]
----

Офисные приложения -- Microsoft Word, LibreOffice Writer -- иногда портят документы при открытии. Например, Microsoft Word заменяет поля на текст «Ошибка. Закладка не определена». Если такие случаи часты, для исключения целесообразно делать соответствующие проверки.

== Выводы

* Предложенная технология универсальна и может быть использована для создания любых документов с высоким уровнем требований по качеству, в том числе, статей на Хабре.
* Asciidoc дает много возможностей по проверке качества документации. В совокупности они позволяют проверить оформление исходных файлов, качество текста, структуру документов и{nbsp}т.п.
* Наличие нативного статического анализатора для Asciidoc могло бы значительно упростить процесс задания правил для проверки документации.
* Результат проверки данной статьи -- [.no-spell]`12 runs, 15 assertions, 0 failures, 0 errors, 0 skips`, а ошибки всё равно есть. https://courseorchestra.github.io/celesta/en/#system_tables[PRs are welcome].

//== todo
//
//* Доработать девопс
//** Сделать выкладку контейнера в докер хаб
//** Пустой dlist
//** Создать репозиторий для статьи